# Laravel Development Rules

## General PHP & Laravel Guidelines

### Code Style & Standards
- Follow PSR-12 coding standards for PHP
- Use Laravel's built-in conventions and naming patterns
- Prefer explicit over implicit code - be clear about intentions
- Use meaningful variable and method names that describe their purpose
- Keep functions and methods small and focused on a single responsibility

### File Organization & Naming
- Controllers: PascalCase with "Controller" suffix (e.g., `UserController`)
- Models: PascalCase singular nouns (e.g., `User`, `BlogPost`)
- Migrations: snake_case with descriptive names (e.g., `create_users_table`)
- Views: snake_case with dot notation (e.g., `auth.login`, `users.index`)
- Routes: kebab-case for URLs (e.g., `/user-profile`, `/blog-posts`)
- Database tables: snake_case plural (e.g., `users`, `blog_posts`)
- Database columns: snake_case (e.g., `first_name`, `created_at`)

### Laravel Conventions
- Use Eloquent relationships instead of manual joins when possible
- Utilize Laravel's built-in validation instead of custom validation logic
- Prefer dependency injection over service locators
- Use Laravel's built-in authentication and authorization features
- Follow RESTful resource controller patterns
- Use route model binding when appropriate
- Implement proper middleware for authentication and authorization

### Database & Eloquent
- Always use migrations for database schema changes
- Use seeders for development and testing data
- Implement proper foreign key constraints
- Use Eloquent relationships to define model associations
- Add database indexes for frequently queried columns
- Use soft deletes when data should be preserved
- Implement proper mass assignment protection with `$fillable` or `$guarded`

### Security Best Practices
- Always validate and sanitize user input
- Use Laravel's built-in CSRF protection
- Implement proper authorization using Gates and Policies
- Use HTTPS in production environments
- Store sensitive data in environment variables, never in code
- Use Laravel's encryption features for sensitive data storage
- Implement rate limiting for API endpoints
- Sanitize data before database insertion and display

### Performance Optimization
- Use eager loading to prevent N+1 query problems
- Implement database query optimization and proper indexing
- Use Laravel's caching mechanisms (Redis, Memcached)
- Optimize images and assets for web delivery
- Use queue jobs for time-consuming tasks
- Implement pagination for large datasets
- Use database transactions for multiple related operations

### Testing Guidelines
- Write unit tests for business logic and models
- Create feature tests for HTTP endpoints and user flows
- Use Laravel's testing utilities (factories, mocking, etc.)
- Test both positive and negative scenarios
- Aim for high test coverage on critical business logic
- Use descriptive test method names that explain what is being tested
- Mock external services and dependencies in tests

### Error Handling & Logging
- Use Laravel's exception handling mechanisms
- Log errors with appropriate context and severity levels
- Provide user-friendly error messages
- Use custom exception classes for domain-specific errors
- Implement proper error reporting for production environments

### Code Documentation
- Write clear docblocks for classes and complex methods
- Document API endpoints with proper parameter descriptions
- Keep README files updated with setup and deployment instructions
- Document environment variables and their purposes
- Use type hints for method parameters and return types

### Frontend Guidelines (when applicable)
- Use Laravel Mix/Vite for asset compilation
- Follow component-based architecture for JavaScript
- Use SCSS/Sass for CSS preprocessing
- Implement responsive design principles
- Optimize images and use appropriate formats (WebP, etc.)

### Environment & Configuration
- Use different configurations for different environments
- Store environment-specific values in `.env` files
- Never commit sensitive information to version control
- Use Laravel's configuration caching in production
- Implement proper logging levels for different environments

### API Development
- Use Laravel Sanctum or Passport for API authentication
- Implement proper API versioning strategies
- Use Laravel Resources for consistent API responses
- Implement proper HTTP status codes
- Add rate limiting and throttling for API endpoints
- Document APIs with tools like OpenAPI/Swagger

### Deployment & DevOps
- Use Laravel Forge, Envoyer, or similar tools for deployment
- Implement proper CI/CD pipelines
- Use Laravel's artisan commands for maintenance tasks
- Implement proper backup strategies for databases
- Use Laravel Horizon for queue monitoring (if using queues)
- Monitor application performance and errors in production

### Package Management
- Keep dependencies updated and secure
- Use semantic versioning for package requirements
- Prefer Laravel-specific packages when available
- Evaluate package maintenance and community support before adoption

### Code Review Guidelines
- Review for adherence to Laravel conventions
- Check for security vulnerabilities
- Ensure proper error handling
- Verify test coverage for new features
- Review database queries for performance
- Ensure proper documentation is included

## Specific Patterns to Follow

### Controller Patterns
```php
// Prefer this
public function store(StoreUserRequest $request): RedirectResponse
{
    $user = User::create($request->validated());

    return redirect()->route('users.show', $user)
        ->with('success', 'User created successfully.');
}

// Over this
public function store(Request $request)
{
    // manual validation and creation logic
}
```

### Model Relationships
```php
// Define relationships clearly
public function posts(): HasMany
{
    return $this->hasMany(Post::class);
}

public function user(): BelongsTo
{
    return $this->belongsTo(User::class);
}
```

### Service Classes
```php
// Use service classes for complex business logic
class UserService
{
    public function createUser(array $data): User
    {
        // Complex user creation logic
    }
}
```

Remember: These rules serve as guidelines to maintain consistency and quality. Adapt them as needed for specific project requirements while maintaining the spirit of clean, maintainable code.




